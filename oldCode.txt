# Creates copies for the shares
    shareDocs = []
    fileID = file.get('documentId')
    id_list = []

    # Makes copies of the original document
    for copies in range(3):
        copied_file = {'title': 'Share' + str(copies + 1)}
        ShareDoc = service.files().copy(fileId=fileID, body=copied_file).execute()
        shareID = ShareDoc.get('id')
        id_list.append(shareID)
        shareDoc = doc_service.documents().get(documentId=shareID).execute()
        shareDocs.append(shareDoc)

    # Get the content of the original document
    doc_content = file.get('body').get('content')

    hasOrigContent = 1

    requests = []

    for i in reversed(range(len(doc_content))):
        if 'paragraph' in doc_content[i]:
            text = doc_content[i].get('paragraph').get('elements')[0].get('textRun').get('content')
            SSShares = SSSTest.SSSText(text)

            # The start index and the end index where the location of the paragraph
            si = doc_content[i].get('paragraph').get('elements')[0].get('startIndex')
            ei = doc_content[i].get('paragraph').get('elements')[0].get('endIndex')

            # Gets the sss shares from each letter
            # j = 0 to length of the share content - 1
            for j in range(len(SSShares)):

                # Split the share between the three doc shares
                # k = 0 to 2
                for k in range(len(SSShares[j])):
                    # Get current element in content position i from each copy
                    shareDocContent = shareDocs[k].get('body').get('content')[i]
                    # If the element in content is a paragraph
                    if 'paragraph' in shareDocContent:
                        doc = shareDocContent.get('paragraph').get('elements')[0].get('textRun')

                        # Remove Original Content from textrun.content
                        if(hasOrigContent == 1):
                            deleteRequest = [{
                                'replaceAllText': {
                                'containsText': {
                                    'text': text,
                                    'matchCase':  'true'
                                },
                                'replaceText': "\n",
                            }}]

                            doc_service.documents().batchUpdate(documentId=id_list[k], body={'requests': deleteRequest}).execute()

                        # Add share to the current copy
                        requestInsert=[{
                            'insertText': {
                                'location': {
                                    'index': si,
                                },
                            'text': str(SSShares[j][k])
                            }
                        }]

                        doc_service.documents().batchUpdate(documentId=id_list[k], body={'requests': requestInsert}).execute()



            # Set it back for the next content
            hasOrigContent = 1

        # If the next element in the document is a table
        elif 'table' in doc_content[i]:
            table = doc_content[i].get('table')

#UPDATE FILE
#    for copies in range(len(shareDocs)):
#        media_body = MediaFileUpload('jsonDocx' + str(copies)+'.txt', mimetype='application/json', resumable=True)
#        updated_file = service.files().update(fileId=id_list[copies],
#        body=shareDocs[copies],
#        media_body=media_body).execute()

    with open('FirstDocx.txt', 'w') as f:
        sys.stdout = f
        print(json.dumps(file, indent=4, sort_keys=True))

    # Output json
    for index in range(3):
        with open('jsonDocx' + str(index) +'.txt', 'w') as f:
            sys.stdout = f
            print(json.dumps(shareDocs[index], indent=4, sort_keys=True))
